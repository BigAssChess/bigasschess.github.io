<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Big ASS Chess â€“ Play vs Computer</title>
    <style>
        /* Full-viewport container, no scrolling, centered content */
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #121212;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(60, 50, 40, 0.6), transparent 50%),
                radial-gradient(circle at 80% 30%, rgba(70, 70, 60, 0.6), transparent 50%),
                radial-gradient(circle at 50% 80%, rgba(50, 60, 60, 0.6), transparent 50%),
                conic-gradient(from 45deg, rgba(60, 50, 40, 0.6), rgba(50, 60, 60, 0.6), rgba(60, 50, 40, 0.6));
            background-blend-mode: multiply;
            font-family: sans-serif;
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #fff;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            font-size: 2rem;
            font-weight: bold;
            color: #333;
        }

        .modal-buttons button {
            margin: 0.5rem;
            padding: 0.75rem 1.5rem;
            font-size: 1.25rem;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #4e342e;
            color: white;
            transition: background 0.2s;
        }
        .modal-buttons button:hover {
            background: #6d4c41;
        }

        /* Board container with layering */
        .board-container {
            position: relative;
            display: inline-block;
        }

        :root {
            /* Dynamic cell size */
            --cell-size: calc(min(100vw / 20, 100vh / 15));
        }

        .board {
            position: relative;
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(15, 1fr);
            width: calc(var(--cell-size) * 20 * 0.95);
            height: calc(var(--cell-size) * 15 * 0.95);
            border: 8px solid #3e2723;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
        }

        .light { background-color: #eeeed2; }
        .dark { background-color: #769656; } /* Slightly greener standard chess color */

        /* Canvas for "thinking lines" */
        #thinkingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }

        /* --- NEW PIECE STYLING --- */
        .piece {
            width: 100%;
            height: 100%;
            background-repeat: no-repeat;
            background-position: center;
            background-size: 85%; /* Pieces fill 85% of square */
            position: absolute;
            pointer-events: none;
            z-index: 3;
            /* Drop shadow for depth on the sprites */
            filter: drop-shadow(2px 4px 3px rgba(0,0,0,0.4));
        }

        /* Animation Clone */
        .moving-piece {
            z-index: 100;
            pointer-events: none;
            will-change: transform;
            width: calc(var(--cell-size) * 0.95); /* match grid cell size roughly */
            height: calc(var(--cell-size) * 0.95);
        }

        /* Highlight styles */
        .check-highlight {
            background-color: #ff5555 !important; /* Redder check */
        }

        .highlight {
            /* Little dot or highlight overlay for valid moves */
            box-shadow: inset 0 0 0 4px rgba(0,0,0,0.2);
            background-color: #f7f769 !important;
        }

        .move-highlight {
            background-color: #bbcb2b !important; /* Lichess-style move highlight */
        }
    </style>
</head>

<body>
    <div class="board-container">
        <canvas id="thinkingCanvas"></canvas>
        <div class="board" id="chessboard"></div>
    </div>

    <div id="welcomeModal" class="modal">
        <div class="modal-content">Welcome to Big ASS Chess</div>
        <div class="modal-buttons">
            <button id="playWhite">Play as White</button>
            <button id="playBlack">Play as Black</button>
        </div>
    </div>

    <div id="alertModal" class="modal" style="display:none;">
        <div class="modal-content" id="modal-message"></div>
        <div class="modal-buttons">
            <button id="modal-button">Restart Game</button>
        </div>
    </div>

    <script>
        /***** ASSETS (Wikimedia Commons SVGs) *****/
        const PIECE_ASSETS = {
            white: {
                king:   "https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg",
                queen:  "https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg",
                rook:   "https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg",
                bishop: "https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg",
                knight: "https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg",
                pawn:   "https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg"
            },
            black: {
                king:   "https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg",
                queen:  "https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg",
                rook:   "https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg",
                bishop: "https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg",
                knight: "https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg",
                pawn:   "https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg"
            }
        };

        /***** Global Variables *****/
        window.showVisualization = true;
        window.maxThinkTimeSeconds = 5;

        let userSide = null;
        let engineColor = null;
        let currentTurn = null;
        let selectedPiece = null;
        let selectedPosition = null;
        let gameOver = false;

        let visualizationCounter = 0;
        let lastMoveFrom = null;
        let lastMoveTo = null;

        const boardElem = document.getElementById("chessboard");
        const thinkingCanvas = document.getElementById("thinkingCanvas");
        const welcomeModal = document.getElementById("welcomeModal");
        const alertModal = document.getElementById("alertModal");
        const modalMessage = document.getElementById("modal-message");
        const modalButton = document.getElementById("modal-button");
        const playWhiteBtn = document.getElementById("playWhite");
        const playBlackBtn = document.getElementById("playBlack");

        const rows = 15;
        const cols = 20;
        const setup = Array.from({ length: rows }, () => Array(cols).fill(null));

        /**************** PIECE PLACEMENT ****************/
        function placePieces(board, isWhite) {
            const colorName = isWhite ? 'white' : 'black';
            const rank1 = isWhite ? 14 : 0;
            const rank2 = isWhite ? 13 : 1;
            const rank3 = isWhite ? 12 : 2;
            const rank4 = isWhite ? 11 : 3;

            const firstRankPattern = [
                'rook', 'bishop', 'queen', 'bishop', 'rook', 'knight', 'bishop', 'rook', 'queen', 'knight',
                'king',
                'bishop', 'queen', 'rook', 'bishop', 'knight', 'rook', 'bishop', 'queen', 'rook'
            ];
            for (let c = 0; c < 20; c++) {
                board[rank1][c] = { color: colorName, type: firstRankPattern[c] };
            }

            const secondCols = [2, 4, 6, 8, 10, 11, 13, 15, 17, 19];
            const secondTypes = ['rook', 'bishop', 'queen', 'rook', 'bishop', 'rook', 'queen', 'rook', 'bishop', 'queen'];
            for (let i = 0; i < 10; i++) {
                board[rank2][secondCols[i]] = { color: colorName, type: secondTypes[i] };
            }

            const thirdCols = [5, 9, 10, 14, 18];
            const thirdTypes = ['rook', 'queen', 'rook', 'bishop', 'queen'];
            for (let i = 0; i < 5; i++) {
                board[rank3][thirdCols[i]] = { color: colorName, type: thirdTypes[i] };
            }

            for (let c = 0; c < cols; c++) {
                board[rank4][c] = { color: colorName, type: 'pawn' };
            }
        }

        placePieces(setup, true);
        placePieces(setup, false);

        /**************** UTILS ****************/
        function inBounds(r, c) { return r >= 0 && r < rows && c >= 0 && c < cols; }
        function copyBoard(board) { return board.map(row => row.map(piece => piece ? { ...piece } : null)); }

        /**************** MOVE GENERATION ****************/
        function getLegalMovesForPiece(row, col, boardState) {
            const pieceObj = boardState[row][col];
            if (!pieceObj) return [];
            const moves = [];
            const color = pieceObj.color;
            const opponent = (color === 'white') ? 'black' : 'white';

            function slide(dR, dC) {
                let r = row, c = col;
                while (true) {
                    r += dR; c += dC;
                    if (!inBounds(r, c)) break;
                    if (!boardState[r][c]) {
                        moves.push({ row: r, col: c });
                    } else {
                        if (boardState[r][c].color === opponent) {
                            moves.push({ row: r, col: c });
                        }
                        break;
                    }
                }
            }

            switch (pieceObj.type) {
                case 'king':
                    for (let dR = -1; dR <= 1; dR++) {
                        for (let dC = -1; dC <= 1; dC++) {
                            if (dR === 0 && dC === 0) continue;
                            const rr = row + dR, cc = col + dC;
                            if (inBounds(rr, cc)) {
                                const occupant = boardState[rr][cc];
                                if (!occupant || occupant.color === opponent) moves.push({ row: rr, col: cc });
                            }
                        }
                    }
                    break;
                case 'queen':
                    slide(-1, 0); slide(1, 0); slide(0, -1); slide(0, 1);
                    slide(-1, -1); slide(-1, 1); slide(1, -1); slide(1, 1);
                    break;
                case 'rook':
                    slide(-1, 0); slide(1, 0); slide(0, -1); slide(0, 1);
                    break;
                case 'bishop':
                    slide(-1, -1); slide(-1, 1); slide(1, -1); slide(1, 1);
                    break;
                case 'knight': {
                    const offsets = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    for (const [dr, dc] of offsets) {
                        const rr = row + dr, cc = col + dc;
                        if (inBounds(rr, cc)) {
                            const occ = boardState[rr][cc];
                            if (!occ || occ.color === opponent) moves.push({ row: rr, col: cc });
                        }
                    }
                    break;
                }
                case 'pawn': {
                    const forward = (color === 'white') ? -1 : 1;
                    const startRow = (color === 'white') ? 11 : 3; 
                    const oneStep = row + forward;
                    if (inBounds(oneStep, col) && !boardState[oneStep][col]) {
                        moves.push({ row: oneStep, col });
                        const twoStep = row + 2 * forward;
                        if (row === startRow && inBounds(twoStep, col) && !boardState[twoStep][col]) {
                            moves.push({ row: twoStep, col });
                        }
                    }
                    for (const dC of [-1, 1]) {
                        const rr = row + forward, cc = col + dC;
                        if (inBounds(rr, cc) && boardState[rr][cc] && boardState[rr][cc].color === opponent) {
                            moves.push({ row: rr, col: cc });
                        }
                    }
                    break;
                }
            }
            return moves;
        }

        function getLegalMovesWithCheck(row, col, board) {
            const piece = board[row][col];
            if (!piece) return [];
            const myColor = piece.color;
            const pseudo = getLegalMovesForPiece(row, col, board);
            return pseudo.filter(m => {
                const newB = copyBoard(board);
                newB[m.row][m.col] = newB[row][col];
                newB[row][col] = null;
                maybePromotePawn(newB, m.row, m.col);
                return !isInCheck(newB, myColor);
            });
        }

        function isInCheck(board, color) {
            let kingPos = null;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const p = board[r][c];
                    if (p && p.type === 'king' && p.color === color) {
                        kingPos = { row: r, col: c }; break;
                    }
                }
                if (kingPos) break;
            }
            if (!kingPos) return false;

            const opp = (color === 'white') ? 'black' : 'white';
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const p = board[r][c];
                    if (p && p.color === opp) {
                        const moves = getLegalMovesForPiece(r, c, board);
                        if (moves.some(m => m.row === kingPos.row && m.col === kingPos.col)) return true;
                    }
                }
            }
            return false;
        }

        function findThreateningPieces(board, kR, kC, kingColor) {
            const threats = [];
            const opp = (kingColor === 'white') ? 'black' : 'white';
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const pc = board[r][c];
                    if (pc && pc.color === opp) {
                        const moves = getLegalMovesForPiece(r, c, board);
                        if (moves.some(m => m.row === kR && m.col === kC)) threats.push({ row: r, col: c });
                    }
                }
            }
            return threats;
        }

        function maybePromotePawn(board, row, col) {
            const piece = board[row][col];
            if (!piece) return;
            if (piece.type === 'pawn') {
                if ((piece.color === 'white' && row === 0) || (piece.color === 'black' && row === rows - 1)) {
                    piece.type = 'queen';
                }
            }
        }

        /**************** RENDER BOARD ****************/
        function renderBoard() {
            boardElem.innerHTML = "";

            const rowIndices = (userSide === 'white') ? [...Array(rows).keys()] : [...Array(rows).keys()].reverse();
            const colIndices = (userSide === 'white') ? [...Array(cols).keys()] : [...Array(cols).keys()].reverse();

            for (let r of rowIndices) {
                for (let c of colIndices) {
                    const square = document.createElement('div');
                    square.classList.add('square', ((r + c) % 2 === 0) ? 'light' : 'dark');
                    square.dataset.row = r;
                    square.dataset.col = c;

                    const piece = setup[r][c];
                    if (piece) {
                        const span = document.createElement('div');
                        span.classList.add('piece');
                        // SET BACKGROUND IMAGE FROM ASSETS
                        const imgUrl = PIECE_ASSETS[piece.color][piece.type];
                        span.style.backgroundImage = `url('${imgUrl}')`;
                        square.appendChild(span);
                    }
                    boardElem.appendChild(square);
                }
            }
            resizeThinkingCanvas();

            if (lastMoveFrom && lastMoveTo) {
                const fromSq = document.querySelector(`.square[data-row="${lastMoveFrom.row}"][data-col="${lastMoveFrom.col}"]`);
                const toSq = document.querySelector(`.square[data-row="${lastMoveTo.row}"][data-col="${lastMoveTo.col}"]`);
                if (fromSq) fromSq.classList.add('move-highlight');
                if (toSq) toSq.classList.add('move-highlight');
            }
        }

        function resizeThinkingCanvas() {
            const rect = boardElem.getBoundingClientRect();
            thinkingCanvas.width = rect.width;
            thinkingCanvas.height = rect.height;
            const ctx = thinkingCanvas.getContext('2d');
            ctx.clearRect(0, 0, rect.width, rect.height);
        }
        window.addEventListener('resize', () => renderBoard());

        function getSquareCenter(row, col) {
            const sq = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            if (!sq) return null;
            const boardRect = boardElem.getBoundingClientRect();
            const sqRect = sq.getBoundingClientRect();
            return {
                x: (sqRect.left + sqRect.right) / 2 - boardRect.left,
                y: (sqRect.top + sqRect.bottom) / 2 - boardRect.top
            };
        }

        function drawThinkingLine(fromRow, fromCol, toRow, toCol) {
            const ctx = thinkingCanvas.getContext('2d');
            const start = getSquareCenter(fromRow, fromCol);
            const end = getSquareCenter(toRow, toCol);
            if (!start || !end) return;
            ctx.strokeStyle = "rgba(100, 255, 100, 0.3)"; 
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            const midX = (start.x + end.x) / 2, midY = (start.y + end.y) / 2;
            const ctrlX = midX + (Math.random() - 0.5) * 20;
            const ctrlY = midY + (Math.random() - 0.5) * 20;
            ctx.quadraticCurveTo(ctrlX, ctrlY, end.x, end.y);
            ctx.stroke();
        }

        /**************** ENGINE ****************/
        const enginePieceValues = { pawn: 100, knight: 330, bishop: 350, rook: 550, queen: 1000, king: 20000 };

        function evaluateKingSafety(board, color) {
            let rK = null, cK = null;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const pc = board[r][c];
                    if (pc && pc.color === color && pc.type === 'king') {
                        rK = r; cK = c; break;
                    }
                }
                if (rK !== null) break;
            }
            if (rK === null) return 0;

            let penalty = 0;
            const opp = (color === 'white') ? 'black' : 'white';
            for (let dR = -1; dR <= 1; dR++) {
                for (let dC = -1; dC <= 1; dC++) {
                    if (dR === 0 && dC === 0) continue;
                    const rr = rK + dR, cc = cK + dC;
                    if (!inBounds(rr, cc)) continue;
                    for (let rr2 = 0; rr2 < rows; rr2++) {
                        for (let cc2 = 0; cc2 < cols; cc2++) {
                            const piece = board[rr2][cc2];
                            if (piece && piece.color === opp) {
                                const moves = getLegalMovesForPiece(rr2, cc2, board);
                                if (moves.some(m => m.row === rr && m.col === cc)) penalty += 15;
                            }
                        }
                    }
                }
            }
            if (isInCheck(board, color)) penalty += 50;
            return penalty;
        }

        function evaluateBoard(board) {
            let base = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const p = board[r][c];
                    if (!p) continue;
                    let val = enginePieceValues[p.type] || 0;
                    if (p.type !== 'king') {
                        const centerR = (rows - 1) / 2, centerC = (cols - 1) / 2;
                        const dist = Math.sqrt((r - centerR) ** 2 + (c - centerC) ** 2);
                        val += (15 - dist) * 5;
                    }
                    base += (p.color === engineColor) ? val : -val;
                }
            }
            const ksEngine = evaluateKingSafety(board, engineColor);
            const otherColor = (engineColor === 'white') ? 'black' : 'white';
            const ksOpp = evaluateKingSafety(board, otherColor);
            return base - ksEngine + ksOpp;
        }

        let transpositionTable = {};
        function boardToString(board) {
            return board.map(row => row.map(p => p ? p.color[0] + p.type[0] : '.').join('')).join('\n');
        }

        function moveScore(board, move) {
            const target = board[move.to.row][move.to.col];
            const attacker = board[move.from.row][move.from.col];
            let sc = 0;
            if (target) sc += (enginePieceValues[target.type] || 0);
            sc -= (enginePieceValues[attacker.type] || 0) / 10;
            return sc;
        }

        function applyMove(board, move) {
            const newB = copyBoard(board);
            newB[move.to.row][move.to.col] = newB[move.from.row][move.from.col];
            newB[move.from.row][move.from.col] = null;
            maybePromotePawn(newB, move.to.row, move.to.col);
            return newB;
        }

        function generateAllMoves(board, color) {
            const all = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color) {
                        const legals = getLegalMovesWithCheck(r, c, board);
                        for (const mv of legals) all.push({ from: { row: r, col: c }, to: { row: mv.row, col: mv.col } });
                    }
                }
            }
            return all;
        }

        function generateCaptureMoves(board, color) {
            const caps = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color) {
                        const pseudo = getLegalMovesForPiece(r, c, board);
                        for (const mv of pseudo) {
                            const tgt = board[mv.row][mv.col];
                            if (tgt && tgt.color !== color) {
                                const newB = copyBoard(board);
                                newB[mv.row][mv.col] = newB[r][c];
                                newB[r][c] = null;
                                maybePromotePawn(newB, mv.row, mv.col);
                                if (!isInCheck(newB, piece.color)) caps.push({ from: { row: r, col: c }, to: { row: mv.row, col: mv.col } });
                            }
                        }
                    }
                }
            }
            return caps;
        }

        async function quiescenceSearch(board, alpha, beta) {
            let standPat = evaluateBoard(board);
            if (standPat >= beta) return beta;
            if (alpha < standPat) alpha = standPat;

            const captures = generateCaptureMoves(board, engineColor);
            captures.sort((a, b) => moveScore(board, b) - moveScore(board, a));
            for (const mv of captures) {
                visualizationCounter++;
                if (window.showVisualization && (visualizationCounter % 100 === 0)) {
                    drawThinkingLine(mv.from.row, mv.from.col, mv.to.row, mv.to.col);
                    await new Promise(res => setTimeout(res, 0));
                }
                const newB = applyMove(board, mv);
                const score = -(await quiescenceSearch(newB, -beta, -alpha));
                if (score >= beta) return beta;
                if (score > alpha) alpha = score;
            }
            return alpha;
        }

        async function minimax(board, depth, alpha, beta, maximizingPlayer) {
            const boardKey = boardToString(board);
            const stored = transpositionTable[boardKey];
            if (stored && stored.depth >= depth) return stored.score;
            if (depth === 0) return await quiescenceSearch(board, alpha, beta);

            const currentColor = maximizingPlayer ? engineColor : (engineColor === 'white' ? 'black' : 'white');
            const moves = generateAllMoves(board, currentColor);
            if (moves.length === 0) {
                if (isInCheck(board, currentColor)) return maximizingPlayer ? -Infinity : Infinity;
                return 0;
            }
            moves.sort((a, b) => moveScore(board, b) - moveScore(board, a));

            let best = maximizingPlayer ? -Infinity : Infinity;
            for (const mv of moves) {
                visualizationCounter++;
                if (window.showVisualization && (visualizationCounter % 100 === 0)) {
                    drawThinkingLine(mv.from.row, mv.from.col, mv.to.row, mv.to.col);
                    await new Promise(res => setTimeout(res, 0));
                }
                const newB = applyMove(board, mv);
                const score = await minimax(newB, depth - 1, alpha, beta, !maximizingPlayer);

                if (maximizingPlayer) {
                    if (score > best) best = score;
                    if (score > alpha) alpha = score;
                } else {
                    if (score < best) best = score;
                    if (score < beta) beta = score;
                }
                if (beta <= alpha) break;
            }
            transpositionTable[boardKey] = { score: best, depth };
            return best;
        }

        async function findBestMove(board, maxDepth, timeLimitMs) {
            const startTime = Date.now();
            let bestMove = null;
            let bestEval = -Infinity;
            transpositionTable = {};
            visualizationCounter = 0;

            const moves = generateAllMoves(board, engineColor);
            for (let depth = 1; depth <= maxDepth; depth++) {
                moves.sort((a, b) => moveScore(board, b) - moveScore(board, a));
                for (const mv of moves) {
                    if (Date.now() - startTime > timeLimitMs) break;
                    visualizationCounter++;
                    if (window.showVisualization && (visualizationCounter % 100 === 0)) {
                        drawThinkingLine(mv.from.row, mv.from.col, mv.to.row, mv.to.col);
                        await new Promise(res => setTimeout(res, 0));
                    }
                    const newB = applyMove(board, mv);
                    const evalScore = await minimax(newB, depth - 1, -Infinity, Infinity, false);
                    if (evalScore > bestEval) {
                        bestEval = evalScore;
                        bestMove = mv;
                    }
                    if (Date.now() - startTime > timeLimitMs) break;
                }
                if (Date.now() - startTime > timeLimitMs) break;
            }
            return bestMove;
        }

        /**************** BOARD INTERACTION ****************/
        boardElem.addEventListener('click', e => {
            if (gameOver) return;
            const sq = e.target.closest('.square');
            if (!sq) return;
            const r = parseInt(sq.dataset.row, 10), c = parseInt(sq.dataset.col, 10);

            if (selectedPiece && sq.classList.contains('highlight')) {
                lastMoveFrom = null; lastMoveTo = null;
                movePiece(selectedPosition.row, selectedPosition.col, r, c);
                clearHighlights(false);
                selectedPiece = null; selectedPosition = null;
            }
            else if (setup[r][c] && setup[r][c].color === currentTurn) {
                clearHighlights(true);
                selectPiece(r, c);
            }
            else {
                clearHighlights(true);
                selectedPiece = null; selectedPosition = null;
            }
        });

        function selectPiece(row, col) {
            selectedPiece = setup[row][col];
            selectedPosition = { row, col };
            const moves = getLegalMovesWithCheck(row, col, setup);
            for (const m of moves) {
                const sq = document.querySelector(`.square[data-row="${m.row}"][data-col="${m.col}"]`);
                if (sq) sq.classList.add('highlight');
            }
        }

        function clearHighlights(keepEnemy) {
            const allSq = document.querySelectorAll('.square');
            allSq.forEach(sq => {
                sq.classList.remove('check-highlight', 'highlight');
                if (!keepEnemy) sq.classList.remove('move-highlight');
            });
        }

        function movePiece(fromR, fromC, toR, toC) {
            const movingPiece = setup[fromR][fromC];
            const sourceSq = document.querySelector(`.square[data-row="${fromR}"][data-col="${fromC}"]`);
            const destSq = document.querySelector(`.square[data-row="${toR}"][data-col="${toC}"]`);
            if (!movingPiece || !sourceSq || !destSq) return;

            const pieceElem = sourceSq.querySelector('.piece');
            if (!pieceElem) {
                setup[toR][toC] = movingPiece;
                setup[fromR][fromC] = null;
                maybePromotePawn(setup, toR, toC);
                finalizeMove(fromR, fromC, toR, toC);
                return;
            }

            const boardRect = boardElem.getBoundingClientRect();
            const srcRect = pieceElem.getBoundingClientRect();
            const dstRect = destSq.getBoundingClientRect();

            const startX = srcRect.left - boardRect.left;
            const startY = srcRect.top - boardRect.top;
            const endX = dstRect.left - boardRect.left;
            const endY = dstRect.top - boardRect.top;

            const clone = pieceElem.cloneNode(true);
            clone.classList.add('moving-piece');
            clone.style.position = 'absolute';
            clone.style.left = startX + 'px';
            clone.style.top = startY + 'px';
            boardElem.appendChild(clone);

            pieceElem.style.visibility = 'hidden';
            clone.offsetWidth; 
            clone.style.transition = 'transform 0.25s linear';
            clone.style.transform = `translate3d(${endX - startX}px, ${endY - startY}px, 0)`;

            clone.addEventListener('transitionend', () => {
                clone.remove();
                setup[toR][toC] = movingPiece;
                setup[fromR][fromC] = null;
                maybePromotePawn(setup, toR, toC);
                finalizeMove(fromR, fromC, toR, toC);
            }, { once: true });
        }

        function finalizeMove(fromR, fromC, toR, toC) {
            const prevTurn = currentTurn;
            currentTurn = (currentTurn === 'white') ? 'black' : 'white';
            renderBoard();
            checkGameStatus();

            if (prevTurn !== userSide) {
                lastMoveFrom = { row: fromR, col: fromC };
                lastMoveTo = { row: toR, col: toC };
                renderBoard();
            }

            if (!gameOver && currentTurn === engineColor) {
                computerTurn();
            }
        }

        function checkGameStatus() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => sq.classList.remove('check-highlight'));

            if (isInCheck(setup, currentTurn)) {
                let hasLegal = false;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const p = setup[r][c];
                        if (p && p.color === currentTurn) {
                            const legals = getLegalMovesWithCheck(r, c, setup);
                            if (legals.length > 0) { hasLegal = true; break; }
                        }
                    }
                    if (hasLegal) break;
                }

                let kPos = null;
                for (let rr = 0; rr < rows; rr++) {
                    for (let cc = 0; cc < cols; cc++) {
                        const pc = setup[rr][cc];
                        if (pc && pc.type === 'king' && pc.color === currentTurn) {
                            kPos = { row: rr, col: cc }; break;
                        }
                    }
                    if (kPos) break;
                }
                if (kPos) {
                    const ksq = document.querySelector(`.square[data-row="${kPos.row}"][data-col="${kPos.col}"]`);
                    if (ksq) ksq.classList.add('check-highlight');
                    const threats = findThreateningPieces(setup, kPos.row, kPos.col, currentTurn);
                    for (const t of threats) {
                        const tsq = document.querySelector(`.square[data-row="${t.row}"][data-col="${t.col}"]`);
                        if (tsq) tsq.classList.add('check-highlight');
                    }
                }

                if (!hasLegal) {
                    showAlertModal("Checkmate! " + (currentTurn === 'white' ? "Black" : "White") + " wins.", true);
                    gameOver = true;
                }
            }
        }

        async function computerTurn() {
            if (gameOver || currentTurn !== engineColor) return;
            const delay = 3000 + Math.random() * 4000;
            await new Promise(res => setTimeout(res, delay));

            const maxDepth = 6;
            const timeLimitMs = window.maxThinkTimeSeconds * 1000;
            const best = await findBestMove(setup, maxDepth, timeLimitMs);
            if (best) movePiece(best.from.row, best.from.col, best.to.row, best.to.col);
        }

        function showAlertModal(msg, isMate) {
            modalMessage.textContent = msg;
            alertModal.style.display = 'flex';
            modalButton.textContent = isMate ? "Restart Game" : "OK";
        }
        function hideAlertModal() { alertModal.style.display = 'none'; }
        modalButton.addEventListener('click', () => {
            hideAlertModal();
            if (gameOver) location.reload();
        });

        playWhiteBtn.addEventListener('click', () => {
            userSide = 'white'; engineColor = 'black'; currentTurn = 'white';
            welcomeModal.style.display = 'none'; renderBoard();
        });
        playBlackBtn.addEventListener('click', () => {
            userSide = 'black'; engineColor = 'white'; currentTurn = 'white';
            welcomeModal.style.display = 'none'; renderBoard();
            if (currentTurn === engineColor && !gameOver) computerTurn();
        });

        welcomeModal.style.display = 'flex';
        renderBoard();
    </script>
</body>

</html>
